### Variable declaration 

* val - Immutable variables
* var - Mutable variables 

### Top-Level functions
    THese are equivalent of static method in Java, for example the Utility functions.
In Kotlin, there is no need to have class that holds the funciton. 

#### Kotlin File vs. Kotlin Class 
___Kotlin File___ hold the top-level funcitons and variables 
These top-level functions can be accessed/invoked from other classes, by referencing the package and the funciton name. 

### Data class 
DTOs (data transfer objects), Domain classes, and value objects are the best examples of Data classes 

***Data Classes*** have '''data''' in front of the '''class''' keyword 
> Example: 
``` 
    data class Course(
        val is: Int,
        val name: String
    )
``` 

Kotlin autogenerates these methods: equals(), hashCode(), and toString()
Data class must have at least one constructor 

Coolest feature is the .copy() method to get a new instance with all the same attributes

## Key Kotlin - Object concepts 

* ___Any___ is the superclass for all Kotlin classes. [Object in Java]
* By default all classes in Kotlin are ___Final___ and as such cannot be extended 
* If an class wants to allow extending the class, it needs to defined with key word ___open___ 
> open class User(val name: String) {...}
* Subclass that extends this will look like 
> class Student(name: String) ___: User(name)___
* A class can extend only one class, similar to Java we cannot extend from more than one class 

<https://kotlinlang.org/docs/inheritance.html#derived-class-initialization-order>

### Overriding functions 
Similar to open keyword used to allow a class to be extended, open keyword can be used to allow for a function to be overloaded. 

### Overriding variables 

## Object Keyword 

'object' keyword allows us to create a class and an instance of it at the sametime. 
Equivalent to singleton pattern in Java
```

object Authenticate {
    fun authenticate(userId : String, password : String) {
        println("Implement the auth framework") 
    }
}
```
Usage 
```
fun main() {
        Authenticate.authenticate("userId", "passcode")
}
```

### Companion object 

> Equivalent to ```static``` in Java

We have to use ```companion``` if we want to use ```object``` inside a class

## Interfaces 

Interfaces are very similar to Java interfaces. In Kotlin, we can have both abstract and non-abstract methods in it 
Meaning, there can be some implementation within a Kotlin Interface. Catch is it cannot maintain any object state. 

#### Interface with abstract method 
interface CourseRepository {
    fun getById(id: Int): Course
}

___Usage___
```
class SqlCourseRepository : CourseRepository {
    override fun getById(id: Int): Course{
    return Course(id = id, 
                "Kafka for.. ",
                "Swamy")   
    }
} 
```

#### Interface with abstract method + non-abstract (with implementation) method
```
interface CourseRepository {
    fun getById(id: Int): Course
    fun save(course: Course): Int {
        println("Course: $course")
        return course.id
    }
}
```

### Classes

#### Constructor

Basic class definition

```
class ClassName {
    fun methodInClassName() {
    println(" ... ")
    }
}
```

Class with instance variables

```
class Person(
        val name String,
        val age Int) {
        
    fun methodInPersonClass() {
    println(" Name: $name, and age is $age ")
    }
}
```

Class with instance variables ___and___ default values

```
class Person(
        val name : String = "No Name",
        val age : Int = 0) {
        
    fun methodInPersonClass() {
    println(" Name: $name, and age is $age ")
    }
}
```

#### Secondary constructor

```
class Item() { // there is no parameter in the Class definition 
    var name : String = "TBD"
    constructor(_name : String) : this() {   // ___constructor___ is a keyword ``` this() ``` calls the default constructor 
        name = _name
    }
}

```

Initialization code using ```init``` block

```
class Person(
        val name : String = "No Name",
        val age : Int = 0) {
    init {
        println("An instance of Person object is being created!")
    }
    fun methodInPersonClass() {
    println(" Name: $name, and age is $age ")
    }
}
```

### Data classes

##### Beans, DTO and domain classes

```
data class Course(
        val id : Int,
        val name : String,
        val author : String) {
        
    fun methodInDataClass() {
    println(" Name: $name, written by  $author ")
    }
}
```

Key advantages of using Data class

##### Autogenerated implementations for some of the default methods

* equals()
* hashCode()
* toString()
* copy() // new instance with all the attributes copied

#### Custom getters and setters

Backing field is used to access the field directly from within get() and set()
These get() and set() methods must be right below the field definition

```
class Item() { // there is no parameter in the Class definition 
    var name : String = "TBD"
    var price: Double
    
     // get ; get() = ... ; get() {... }
    }
}

```

#### Inheritance

### use keyword ```open```

Inheritance.kt

....
<hr>

#### Visibility Modifiers

* public [default]
* protected : functions and variables are visible in the class and its sub-classes
* private : function or variable will be accessible only within the class
* internal : Is private to the module that's published using Gradle or Maven

#### Type Checking, Casting & Smart Casting

```is``` operator
val name = "Swamy"
println(name is String)
<hr>

### Nullable ```?```

#### Safe Operator ```?```

#### Elvis operator ```?:```

#### Not-Null Assertion ```!!```

___Nullable___
to define a variable that can support Null
> ```var nameNullable : String? = null ```

___Safe call operator ?___<br>
Inorder to avoid Null Pointer Exception

> ``` val length = nameNullable?.length?.toLong() ``` <br>
> The ? at the end of the variables directs Kotlin to check if it is Null, and do the operation only if it is not null

___Elvis operator ?:___ <br>
Use this to assign a 'default' value if/when the variable is NULL
> ``` val length = nameNullable?.length ?: 0  ``` <br>
> with ?: a value of 0 is assigned to _length_ if righthand side expression returns NULL

___Not-Null Assertion !!___<br>

When a variable has !! at the end of it, Kotlin will make sure it is not NULL.
If the value is NULL, it will throw NullPointerException 









 





























